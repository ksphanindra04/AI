import heapq

class PuzzleState:
    def __init__(self, board, g, goal, parent=None):
        self.board = tuple(board)
        self.g = g
        self.parent = parent
        self.zero = self.board.index(0)
        self.goal = goal

    def __lt__(self, other):
        return (self.g + self.manhattan()) < (other.g + other.manhattan())

    def __eq__(self, other):
        return self.board == other.board
   
    def __hash__(self):
        return hash(self.board)

    def get_moves(self):
        moves = []
        x, y = divmod(self.zero, 3)
        dirs = [(-1,0),(1,0),(0,-1),(0,1)]
        for dx, dy in dirs:
            nx, ny = x+dx, y+dy
            if 0<=nx<3 and 0<=ny<3:
                npos = nx*3+ny
                new_board = list(self.board)
                new_board[self.zero], new_board[npos] = new_board[npos], new_board[self.zero]
                moves.append(PuzzleState(new_board, self.g+1, self.goal, self))
        return moves

    def misplaced(self):
        return sum(1 for i in range(9) if self.board[i]!=0 and self.board[i]!=self.goal[i])

    def manhattan(self):
        dist = 0
        for i in range(9):
            if self.board[i]!=0:
                gi = self.goal.index(self.board[i])
                x1,y1 = divmod(i,3)
                x2,y2 = divmod(gi,3)
                dist+=abs(x1-x2)+abs(y1-y2)
        return dist

    def path(self):
        node, p = self, []
        while node:
            p.append(node.board)
            node=node.parent
        return p[::-1]

def astar(start, goal, heuristic):
    open_list = []
    heapq.heappush(open_list,(0,start))
    closed=set()
    while open_list:
        f, node = heapq.heappop(open_list)
        if node.board==goal:
            return node.path()
        closed.add(node)
        for move in node.get_moves():
            if move in closed:
                continue
            h = move.misplaced() if heuristic=="misplaced" else move.manhattan()
            heapq.heappush(open_list,(move.g+h,move))
    return None

start_list = [1,2,3,4,0,6,7,5,8]
goal_list = [1,2,3,4,5,6,7,8,0]

start_tuple = tuple(start_list)
goal_tuple = tuple(goal_list)

print("Using Misplaced Tiles:")
for state in astar(PuzzleState(start_tuple,0, goal_tuple), goal_tuple, "misplaced"):
    print(state)

print("\nUsing Manhattan Distance:")
for state in astar(PuzzleState(start_tuple,0, goal_tuple), goal_tuple, "manhattan"):
    print(state)